// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

import {MerkleProof} from "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import {ContractOwnershipStorage} from "@animoca/ethereum-contracts/contracts/access/libraries/ContractOwnershipStorage.sol";
import {PauseStorage} from "@animoca/ethereum-contracts/contracts/lifecycle/libraries/PauseStorage.sol";
import {ContractOwnership} from "@animoca/ethereum-contracts/contracts/access/ContractOwnership.sol";
import {Pause} from "@animoca/ethereum-contracts/contracts/lifecycle/Pause.sol";
import {ECDSA} from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import {IERC20SafeTransfers} from "@animoca/ethereum-contracts/contracts/token/ERC20/interfaces/IERC20SafeTransfers.sol";
import {Context} from "@openzeppelin/contracts/utils/Context.sol";
import {IForwarderRegistry} from "@animoca/ethereum-contracts/contracts/metatx/interfaces/IForwarderRegistry.sol";
import {ForwarderRegistryContextBase} from "@animoca/ethereum-contracts/contracts/metatx/base/ForwarderRegistryContextBase.sol";
import {ForwarderRegistryContext} from "@animoca/ethereum-contracts/contracts/metatx/ForwarderRegistryContext.sol";

/// @title EDuCoinMerkleClaim
/// @notice This contract is designed for claiming payouts which will cumulate over time.
/// @notice A merkle tree is generated with one leaf for each claim recipient together with the erc20 reward amount
/// @notice Flow: when new claims become available, the contract is paused to avoid further claims, a new tree is generated by summing up the current
/// @notice unclaimed payouts and the new payouts, per user. The new tree is set and replaces the previous one and the contract is unpaused.
/// @notice A nonce is used for each new tree and is included in every leaf to prevent collisions with claims from previous trees.
/// @notice A signature is used for real time KYC check.
contract EDuCoinMerkleClaim is Pause, ForwarderRegistryContext {
    using ECDSA for bytes32;
    using MerkleProof for bytes32[];
    using ContractOwnershipStorage for ContractOwnershipStorage.Layout;
    using PauseStorage for PauseStorage.Layout;

    IERC20SafeTransfers public immutable ERC20;

    address public messageSigner;
    bytes32 public root;
    uint256 public nonce;
    mapping(bytes32 => bool) public claimed;

    /// @notice Emitted when a new merkle root is set.
    /// @param root The new merkle root.
    event MerkleRootSet(bytes32 root);

    /// @notice Emitted when a new message signer is set.
    /// @param messageSigner The new message signer.
    event MessageSignerSet(address messageSigner);

    /// @notice Emitted when a payout is claimed.
    /// @param root The merkle root on which the claim was made.
    /// @param recipient The recipient of the claim.
    /// @param amount uint256 amount of the ERC20 payout
    /// @param nonce The nonce as when the claim was made.
    event PayoutClaimed(bytes32 indexed root, address indexed recipient, uint256 amount, uint256 nonce);

    /// @notice Thrown when trying to claim the same leaf more than once.
    /// @param recipient The recipient of the claim.
    /// @param amount The encoded claim data for the claim.
    /// @param nonce The nonce as when the claim was made.
    error AlreadyClaimed(address recipient, uint256 amount, uint256 nonce);

    /// @notice Thrown when a proof cannot be verified.
    /// @param recipient The recipient of the claim.
    /// @param amount uint256 amount of the ERC20 payout
    /// @param nonce The nonce as when the claim was made.
    error InvalidProof(address recipient, uint256 amount, uint256 nonce);

    /// @notice Thrown when a signature is invalid.
    /// @param recipient The recipient of the claim.
    /// @param signature The signature that was invalid.
    /// @param expireAt The expireAt of the signature.
    error InvalidSignature(address recipient, bytes signature, uint256 expireAt);

    /// @notice Thrown when a signature is expired.
    /// @param recipient The recipient of the claim.
    /// @param signature The signature that was invalid.
    /// @param expireAt The expireAt of the signature.
    error ExpiredSignature(address recipient, bytes signature, uint256 expireAt);

    /// @dev Emits a MessageSignerSet event.
    constructor(
        IERC20SafeTransfers erc20_,
        address messageSigner_,
        IForwarderRegistry forwarderRegistry_
    ) Pause(true) ContractOwnership(_msgSender()) ForwarderRegistryContext(forwarderRegistry_) {
        ERC20 = erc20_;
        messageSigner = messageSigner_;
        emit MessageSignerSet(messageSigner_);
    }

    /// @notice Sets the merkle root for a new claiming period and unpauses the contract.
    /// @dev Reverts with {NotContractOwner} if the sender is not the contract owner.
    /// @dev Reverts with {NotPaused} if the contract is not paused.
    /// @dev Emits an {Unpaused} event.
    /// @dev Emits a {MerkleRootSet} event.
    /// @param merkleRoot The merkle root to set.
    function setMerkleRoot(bytes32 merkleRoot) public {
        ContractOwnershipStorage.layout().enforceIsContractOwner(_msgSender());
        PauseStorage.layout().unpause();
        root = merkleRoot;
        unchecked {
            ++nonce;
        }
        emit MerkleRootSet(merkleRoot);
    }

    /// @notice Sets the message signer for signature verification.
    /// @dev Reverts with {NotContractOwner} if the sender is not the contract owner.
    /// @dev Emits a {MessageSignerSet} event.
    /// @param messageSigner_ The message signer to set.
    function setMessageSigner(address messageSigner_) public {
        ContractOwnershipStorage.layout().enforceIsContractOwner(_msgSender());
        messageSigner = messageSigner_;
        emit MessageSignerSet(messageSigner_);
    }

    /// @notice Executes the payout for a given user (anyone can call this function).
    /// @dev Reverts with {Paused} if the contract is paused.
    /// @dev Reverts with {AlreadyClaimed} if this specific payout has already been claimed.
    /// @dev Reverts with {InvalidProof} if the merkle proof cannot be verified.
    /// @dev Emits a {PayoutClaimed} event.
    /// @param recipient Address of the user to claim the payout
    /// @param amount uint256 amount of the ERC20 payout
    /// @param proof Merkle proof of the user based on the merkle root
    /// @param signature Signature that signed by the message signer
    /// @param expireAt Expiry time of the signature
    function claimPayout(address recipient, uint256 amount, bytes32[] calldata proof, bytes calldata signature, uint256 expireAt) external {
        PauseStorage.layout().enforceIsNotPaused();

        uint256 currentNonce = nonce;
        bytes32 currentRoot = root;

        if (block.timestamp >= expireAt) {
            revert ExpiredSignature(recipient, signature, expireAt);
        }

        bytes32 sigHash = keccak256(abi.encodePacked(address(this), recipient, expireAt));
        if (sigHash.toEthSignedMessageHash().recover(signature) != messageSigner) {
            revert InvalidSignature(recipient, signature, expireAt);
        }

        bytes32 leaf = keccak256(abi.encodePacked(recipient, amount, currentNonce));

        if (claimed[leaf]) revert AlreadyClaimed(recipient, amount, currentNonce);
        if (!proof.verifyCalldata(currentRoot, leaf)) revert InvalidProof(recipient, amount, currentNonce);

        claimed[leaf] = true;

        emit PayoutClaimed(currentRoot, recipient, amount, currentNonce);

        ERC20.safeTransferFrom(owner(), recipient, amount, new bytes(0));
    }

    /// @inheritdoc ForwarderRegistryContextBase
    function _msgSender() internal view virtual override(Context, ForwarderRegistryContextBase) returns (address) {
        return ForwarderRegistryContextBase._msgSender();
    }

    /// @inheritdoc ForwarderRegistryContextBase
    function _msgData() internal view virtual override(Context, ForwarderRegistryContextBase) returns (bytes calldata) {
        return ForwarderRegistryContextBase._msgData();
    }
}
